\newpage
\section{Измерения}
Одними из наиболее важных подзадач в рамках любой оптимизационной деятельности являются измерение,
трактовка результатов и определение наиболее важных для оптимизации мест.

В рамках данной главы будут изложены основные подходы, используемые при измерениях, результаты
измерений и их анализ.

\subsection{Корректность}
Измерение производительности программ следует производить с особой осторожностью, так как существует
множество различных факторов, в том числе случайных, влияющих на время их работы.

В случае программы для платформы Java, время ее работы во многом зависит от специфики работы
виртуальной машины.
В частности, изучая результаты измерений, следует уточнять:
\begin{itemize}
    \item Достаточно ли времени было у виртуальной машины для того, чтобы скомпилировать наиболее
    <<горячий>> код.

    Чаще всего непосредственно перед замером код бенчмарка запускается некоторое число раз с целью
    <<разогрева>> виртуальной машины.

    Это нужно не только для того, чтобы дать JVM возможность в принципе скомпилировать код, но и
    для накопления достаточного количества информации о профиле программы, чтобы адаптировать
    скомпилированный код для наиболее частых вариантов исполнения, в т.ч. для удачного расположения
    различных процедур в памяти.

    \item Насколько интенсивно запускаемый код аллоцирует динамическую память, достаточно ли ее.

    В случае жестких ограничений на память существенное время работы программы будет потрачено
    на сборку мусора, которая в особых случаях блокирует поток исполнения.

    \item Могла ли виртуальная машина доказать избыточность той части кода, которая подлежит
    измерению, и удалить соответствущие вычисления.

    В случае наличия такой возможности не может быть и речи о корректности измерений.
\end{itemize}

Для преодоления вышеописанных проблем все бенчмарки, описанные в данной работе, были реализованы
с помощью \textit{JMH}\fu{http://openjdk.java.net/projects/code-tools/jmh/}
--- каркаса для бенчмарков, разрабатываемого инженерами компании Oracle.

Каждый бенчмарк  представляет собой метод, отмеченный аннотацией ``Benchmark'', либо с пустым
набором параметров, либо принимающий объект класса ``Blackhole''.

Измерения производительности бенчмарка состоят из регулируемого числа итераций.
В рамках отдельной итерации код бенчмарка запускается несколько раз примерно в течение секунды,
после чего время работы вычисляется как среднее.

Результаты всех итераций рассматриваются, как выборка из нормального распределения с неизвестной
дисперсией, на основе которой вычисляется мат. ожидание, СКО, и доверительный интервал.

JMH предоставляет авторам бенчмарков ряд возможностей для контроля корректности измерений.
\begin{itemize}
    \item Пользователь может устанавливать число итераций разгогрева для каждого бенчмарка.
    Достаточность этого значения можно определить на основе анализа журнала компиляции HotSpot,
    который можно получить, запустив JVM с опцией ``-XX:+LogCompilation''.

    \item С помощью аннотации ``CompilerControl'' можно устанавливать будет ли конкретный метод
    скомпилирован или встроен JIT-компилятором, что позволяет моделировать различные варианты
    его поведения.

    \item JMH гарантирует, что если некоторое значение возвращено методом-бенчмарком или оно
    передано в качестве аргумента методу ``consume'' объекта ``Blackhole'', то виртуальная машина
    не сможет доказать избыточность кода, влияющего на это значение.

    \item В новых версиях JMH появилась возможность находить участки кода, которые исполняются
    дольше всего в процессе измерений.
    Вычисление наиболее <<горячих>> точек происходит с помощью инструмента ``perf''\fu{http://en.wikipedia.org/wiki/Perf_(Linux)},
    доступного для ОС Linux.

    Вывод результатов производится вместе с машинным кодом соответствующих участков на языке
    ассемблера.
    Это позволяет более точно оценить вклад тех или иных инструкций байт-кода в общее время работы
    бенчмарка.
\end{itemize}

\subsection{Условия проведения измерений}
\begin{itemize}
    \item \textbf{Модель ЦПУ:} Intel(R) Core(TM) i7-3540M CPU @ 3.00GHz
    \item \textbf{Операционная система:} Linux 3.11-2-amd64 \#1 SMP Debian 3.11.8-1 (2013-11-13) x86\_64 GNU/Linux
    \item \textbf{Реализация JVM:} Oracle Hotspot
    \item \textbf{Версии Java Runtime Edition:} 1.6.0\_45, 1.7.0\_51, 1.8.0
    \item \textbf{Ключи JVM:} -Xmx1024M -XX:+AggressiveOpt -XX:+DoEscapeAnalysis
\end{itemize}

\subsection{Бенчмарки}
В данном разделе представлено описание реализованных в рамках данной работы бенчмарков, указано
время их работы и проведен анализ недостатков в сгенерированном байт-коде.

Так как абсолютное время работы бенчмарка само по себе по сути не имеет смысла, для каждого из
них создан в некотом роде семантически эквивалетный эталон, производительность которого
с точки зрения автора должна быть близким к оригиналу.

Например при измерениях, нацеленных на проверку простых синтаксических конструкций, таким эталоном
может служить аналогичный код на Java, а при измерении времени работы стандартных функций высшего
порядка их код с заменой вызовов функционального аргумента на тело анонимной функции.

\subsubsection{АВЛ-дерево}
Одним из бенчмарков с существенно нетривиальным кодом стала реализация АВЛ-дерева, используемая
для решения задачи \textit{Stars}\fu{http://acm.timus.ru/problem.aspx?num=1028&locale=ru}.
