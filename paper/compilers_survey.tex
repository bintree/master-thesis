\subsection{Обзор существующих решений}

В рамках данного раздела будут рассмотрены и проанализированы решения, используемые в компиляторах
наиболее популярных языков языков программирования для платформы Java, а также дополнительно
будут рассмотрены отдельные приложения для постобработки сгенерированного байт-кода.

\subsubsection{Java}
Начинать обзор решений из компилятора языка Java следует с упоминания о том, что в принципе
существует несколько полноценных реализаций трансляторов, однако рассмотрены будут только версии,
распространяемые в комплекте Java Development Kit от Oracle, в силу их наибольшей популярности.

К сожалению непросто найти источник информации, исчерпывающе описывающий подходы к оптимизации,
используемые в компиляторах от Oracle, и который при этом можно было бы назвать хоть сколько-нибудь
авторитетным.

Наиболее адекватной и полной кажется статья\cite{JavacOT}.
Предложенные в ней утверждения, кроме того, что они совсем не противоречат здравому смыслу,
еще регулярно подтверждались эмпирически при исследовании байт-кода, получаемого в результате
компиляции бенчмарков, написанных на Java. %% TODO: ссылка на главу про бенчмарки
Основные ее тезисы:
\begin{itemize}
    \item Для многих конструкций языка Java 6 существуют вполне очевидные правила их отображения
    в инструкции JVM, с помощью которых эти конструкции можно выразить.
    И в большинстве случаев компиляторы Java генерируют код весьма прямолинейно, следуя этим
    правилам, так, по что получаемому байт-коду можно зачастую однозначно определить вид исходного
    синтаксического дерева.
    \item В некотором смысле исключениeм является работа с константами:
    почти всегда, когда какое-то выражение может быть вычислено во время компиляции, в байт-коде
    будет уже результат этого вычисления.

    Во многом это поведение описано в спецификации языка, и является полностью корректным,
    хотя в некоторых случаях неочевидным с точки зрения пользователя.

    \item Генерация последовательных применений оператора ``+'' для строк производится с помощью
    класса StringBuilder, что позволяет избежать избыточной аллокации и операций копирования памяти,
    которые неизбежно возникали бы в случае последовательных вызовов метода \textit{concat} у строк.

    \item Компилятор избегает генерацию заведомо мертвого кода, правда лишь в самых простых случаях.

    \item Некоторые простые оптимизации, применяемые при генерации условных операторов, упрощающие
    истиностные выражения в соответствии с законами де Моргана.
\end{itemize}

Кроме описанных в вышеуказанной статье пунктов стоит упомянуть несколько нетривиальную логику,
применяемую при генерации байт-кода для оператора ``switch'' для константных строк и более подробно
описанную в следующей главе. %% TODO: ссылка на главу про switch

Столь скудный набор оптимизаций, проводимых транслятором, вероятно связан с тем, что большая часть
работы с производительностью происходит уже во время работы программы на фазе JIT-компиляции.

В пользу этого утверждения, в частности, говорит тот факт, что в документации к первым версиям
(до появления Hotspot) существовал флаг
<<-O>>\fu{http://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/tooldocs/win32/javac.html},
позволяющий устанавливать уровень оптимизаций, и который впоследствии остался только для
сохранения обратной совместимости.
\fu{http://hg.openjdk.java.net/jdk6/jdk6/langtools/file/a9008b46db24/src/share/classes/com/sun/tools/javac/main/RecognizedOptions.java\#l553}

Одним из выводов, который следует из этой части обзора --- код, генерируемый компилятором Java
может послужить эталоном для разработчика JVM-языка, как минимум в случае, когда
генерируемая конструкция достаточно проста, и присутствует в обоих языках: арифметические выражения,
простые условные операторы и т.д.

В пользу последнего утверждения говорит также факт выполнения JIT-компилятором Hotspot
так называемых Peephole-оптимизаций\cite{HotSpotDesign}, шаблоны которых вполне вероятно могут быть
приспособлены именно для байт-кода, генерируемого компилятором Javac.
Таким образом отступление от шаблонов генерации Java потенциально может привести к ухудшению
производительности.

\subsubsection{Java 8}
Одним из существенных нововведений, появившихся в относительно новой версии Java 8, стал лаконичный
синтаксис для анонимных функций.

В предыдущих версиях в случае необходимости определить функцию, параметризуемый некоторой другой
функцией, создавался интерфейс с одним методом, реализацию которого и следовало передать в первую
функцию.
В популярной среди Java-разработчиков библиотеке <<guava>> для таких случае выделен общий
интерфейс, носящий недвусмысленное название Function\fu{https://code.google.com/p/guava-libraries/wiki/FunctionalExplained}.

Чаще всего для реализации таких интерфейсов использовался громоздкий синтаксис анонимных классов,
с помощью которого функцию-аргумент можно описать в месте вызова функции высшего порядка.
Примерно такой подход использовался и при генерации кода анонимных функций в новых языках для JVM:
для каждой из них генерировался отдельный синтетический класс с одним методом.

При компиляции замыканий в Java 8 используется несколько другой подход\cite{J8LambdaTranslation}:
тело лямбда-функции помещается в отдельный синтетический метод, располагаемый в том же классе,
где происходит вызов функции ожидающей реализацию интерфейса, а уже непосредственно класс-реализация
генериуется в момент первого вызова с помощью байт-код инструкции ``INVOKEDYNAMIC'',
появишвшейся в поздних версиях спецификаций JVM.

Столь сложное и неочевидное решение, принятное инженерами Oracle, вряд ли существенно влияет на
производительность, так как фактически используется все тот же механизм интерфейсов и виртуальных
вызовов, намного сильнее такой подход влияет на число class-файлов в приложении.

Действительно, исходя из предположения об интенсивном использовании замыканий, генерация отдельного
class-файла в каждом месте вызова кажется избыточным, особенно учитывая, что не каждый из них
будет использован.

Однако у решения с ``INVOKEDYNAMIC'' есть как минимум один существенный недостаток: поддержка этой
инструкции существует только в версиях JVM младше седьмой, что сильно ограничивает возможность
использования такого кода в более старших версиях. В свою очередь попытки разработчиков языков
сохранить обратную совместимость например с версией JRE 1.6 зачастую являются не столько данью
консерватизму, сколько необходимостью для пользователей-разработчиков под Android, где по сей день
может быть использован только код, скомпилированный для устаревшей платформы.

\subsubsection{Scala}
\label{section:scala}
Scala --- статически-типизированный мультипарадигменный язык программирования, компилируемый
в том числе под платформу Java, разрабатывается в компании Typesafe.
Системой типов, богатством синтаксических конструкций Scala весьма сильно похож на Kotlin.
В частности оба языка построены исходя из предположения о повсеместном использовании
функций высшего порядка, что сразу поднимает вопрос об эффективности их реализации на уровне
байт-кода.

В качестве основного источника информации о решениях, связанных с производительностью Scala,
автором была выбрана диссертация\cite{ScalaDragos} одного из разработчиков языка,
который, как следует из статьи, занимался оптимизацией байт-кода, генерируемого компилятором.
Основные тезисы статьи будут рассмотрены в этом разделе.

\paragraph{Встраивание}
Корнем многих проблем с производительностью в Scala, как следует из \cite{ScalaDragos}, является
повсеместное использование функциональной парадигмы.
Например конструкция, отдаленно напоминающая цикл ``for'' из императивных языков, на деле является
<<синтаксическим сахаром>> для вызова полиморфной функции ``forEach'' с аргументом-функцией.

Таким образом простой цикл в байт-коде может быть сгенерирован в виде нескольких вызовов функций,
в том числе высшего порядка.

В качестве одного из способов избежать потенциально трудоемких операций вызова, автор предлагает
распространенный в таких случаях подход --- встраивание тела вызываемой функции в место
вызова\cite{Muchnick}.

Зачастую это не только позволяет избежать вызовов, но и открывает дополнительные возможности для
дальнейших оптимизаций.
В частности после встраивания функции высшего порядка может быть встроено также и тело ее
аргумента-функции.

Следует отметить, что в Kotlin механизм встраивания уже был реализован, причем в отличие от Scala,
где решение о необходимости встраивания конкретного вызова принимается компилятором на основе
набора эвристик, в Kotlin это решение детерминировано и определяется наличием специальной
аннотации ``inline'' на вызываемой функции.

В данной работе будет произведена оценка влияния встраивания на производительность.

\paragraph{Постобработка байт-кода в Scala}
Встраивание чаще всего порождает специфичные артефакты, например зачастую избыточные безусловные
переходы ``GOTO'', на которые заменяется инструкция ``RETURN'' из оригинальной функции.

Кроме того, как уже было отмечено, встраимаевамая функция, написанная максимально обобщенно может
при встраивании породить заведомо <<мертвый>> код или избыточные действия.

Например, если в оригинальной функции была проверка аргумента на равенствно null-ссылке, а в месте
встраивания точно известно, что это условие не верно, то эту проверку следовало бы удалить вместе
с соответствующим ветвлением.

Такого рода оптимизации не влияют на семантику кода, но при этом их применение положительно влияет
на размер байт-кода и вероятно на его производительность.

Наиболее типичным способом их реализации является добавление стадии постобработки в компилятор:
уже сгенерированный код исследуется с помощью различных техник программного анализа и в случае
необходимости модифицируется соответствующим образом.

В Scala эта стадия компиляции выполняет следующие оптимизации:
\begin{itemize}
    \item Удаление так называемого <<мертвого>> кода, представляющего из себя блоки инструкций,
    про которые может быть доказано, что они недостижимы при при любом варианте исполнения
    программы.
    \item Устранение избыточного боксинга.
    \item Уточнение типов значений в локальных переменных.
    \item Анализ интервалов времени жизни переменных и устранение сохранений значений,
    которые далее не будут использованы.
\end{itemize}

\paragraph{Copy propagation}
В целом подход к генерации байт-кода для  функций-значений в Scala идентичен подходу,
используемому в Kotlin и описанному в разделе [].% TODO: ref to functional types in kotlin.

Из этого, в частности, следует, что при совсем прямолинейной реализации встраивания в случае
вызова функции высшего порядка в байт-коде неизбежно будет создан объект-замыкание с полями,
значения которых отражают состояние локальных переменных, и доступ к их значениям будет
производиться через обращение к этим полям.

При этом очевидно, что этой косвенности можно и хотелось бы избежать.
В Scala для этого реализован дополнительный анализ в рамках стадии постобработки,
т.н. <<Copy propagation>>, позволяющий в частности обнаружить, что в момент использования значения
некоторой переменной \textit{x} единственным ее значением может быть другая переменная \textit{y},
и соответственно читать \textit{y} вместо \textit{x}. Этот вид анализа описан в \cite{Muchnick}
и является в свою очередь расширением друго вида анализа, называемого в литературе
<<Достигающие определения>>.

В совокупности с анализом интервалов времени жизни переменных <<Copy propagation>> позволяет
избежать использования полей объекта-замыкания, и как следствие создания этого объекта.

Заметим, что устранение <<мертвых>> значений, выполняемых компилятором Scala, не является столь
безобидным, как устранение <<мертвых>> блоков, поскольку, несмотря на инвариантность семантики
получаемого кода, удаленные значения становятся неоступными разработчику в процессе отладки,
что может ввести в заблуждение.

В компилируемых языках проблема неудобства отладки оптимизированных программ решается флагами
компиляции, контролирующими уровень производимых оптимизаций.
Аналогичные флаги присутствуют и в компиляторе Scala\fu{http://www.scala-lang.org/files/archive/nightly/docs-2.10.2/manual/html/scalac.html},
однако пользователи весьма настороженно относятся ко включению оптимизаций.
На сайте известной библиотеки Akka, разрабатываемой в компании Typesafe на Scala настоятельно
рекомендуют не использовать флаг ``-optimise''\fu{http://doc.akka.io/docs/akka/snapshot/intro/getting-started.html}.

\paragraph{Специализация}
Важным дополнением к вышеперечисленным оптимизациям в Scala является частичная специализация
параметрически полиморфных классов.

Если типовой параметр ``T'' класса помечен аннотацией ``specialized'', то при подстановке
примитивного типа в качестве аргумента компилятором будет сгенерирована копия класса, в котором
все упоминания типового параметра и инструкции, оперирующие со значениями типа ``T'' будут
адаптированы для этого примитивного типа.

В частности таким образом проаннотированы параметры интерфейса ``Function1'', таким образом решая
проблему боксинга при использовании функций высшего порядка.

Такой подход не лишен и некоторых недостатков:
\begin{itemize}
    \item При использовании таких классов в рамках полиморфного кода, параметры которого
    не специализируются, компилятор вынужден использовать версию класса со стертыми типами, таким
    образом возможности использования специализации существенно ограничены.
    \item При специализации класса с N типовыми параметрами может быть произведено до $8^N$ копий
    класса --- здесь показатель экспоненты взят по числу примитивных типов.

    Проблема состоит в том, что инфраструктура реализаций JVM с версиями старше восьмой
    не приспособлена для большого числа классов, в частности единожды загруженный класс будет
    занимать место в памяти до завершения процесса виртуальной машины.
\end{itemize}

\subsubsection{ProGuard}
Одним из самых популярных внешних инструментов для оптимизации байт-кода JVM является ProGuard.
По сути главной его задачей является не столько улучшение производительности, сколько уменьшение
размера class-файлов.

ProGuard представляет из себя конвейер из нескольких процедур, которым подвергается набор
class-файлов:
\begin{itemize}
    \item Удаление неиспользуемых (в рамках этого набора классов) методов.
    \item Обфускация --- процесс переименования идентификаторов классов и методов в условно
    бессмысленные, но более короткие. Это нередко позволяет уменьшить размер
    пула констант class-файлов.
    \item Оптимизация тел методов: удаление мертвого кода и т.д.
\end{itemize}

Если первые два пункта явно не следует производить в рамках компиляции --- предполагается,
что ProGuard используется разработчиками только перед фазой размещения итоговой версии продукта ---
то последний может быть интересным в рамках данной работы.

Судя по исходному коду проекта и исходя из официальной документации \fu{http://proguard.sourceforge.net/manual/optimizations.html},
многие применяемые оптимизации отличаются особой <<агрессивностью>> и также не подлежат
применению непосредственно компилятором:
\begin{itemize}
    \item Изменения модальности методов --- методы, не использующие явно другие члены класса можно
    сделать статическими.
    \item Удаление параметров методов, в случае, если для них используется одно и то же константное
    выражение.
    \item Удаление полей, в которые происходит запись, но не чтение.
    \item Встраивание коротких методов.
    \item Упрощение хвостовой рекурсии.
\end{itemize}

Последние два пункта в общем случае кажется разумными, однако они уже реализованы в компиляторе
Kotlin.

Однако некоторые применяемые виды оптимизаций, такие как удаление мертвого кода
и устранение избыточных безусловных переходов были приняты к рассмотрению и реализованы.
