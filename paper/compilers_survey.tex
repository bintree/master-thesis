\subsection{Обзор существующих решений}

В рамках данного раздела будут рассмотрены и проанализированы решения, используемые в компиляторах
наиболее популярных языков языков программирования для платформы Java, а также дополнительно
будут рассмотрены отдельные приложения для постобработки сгенерированного байт-кода.

\subsubsection{Java}
Начинать обзор решений из компилятора языка Java следует с упоминания о том, что в принципе
существует несколько полноценных реализаций трансляторов, однако рассмотрены будут только версии,
распространяемые в комплекте Java Development Kit от Oracle, в силу их наибольшей популярности.

К сожалению непросто найти источник информации, исчерпывающе описывающий подходы к оптимизации,
используемые в компиляторах от Oracle, и который при этом можно было бы назвать хоть сколько-нибудь
авторитетным.

%% https://briangordon.github.io/2014/01/javac-optimizations.html
Наиболее адекватной и полной кажется статья [].
Предложенные в ней утверждения, кроме того, что они совсем не противоречат здравому смыслу,
еще регулярно подтверждались эмпирически при исследовании байт-кода, получаемого в результате
компиляции бенчмарков, написанных на Java. %% Ссылка на бенчмарки
Основные ее тезисы:
\begin{itemize}
    \item Для многих конструкций языка Java 6 существуют вполне очевидные правила их отображения
    в инструкции JVM, с помощью которых эти конструкции можно выразить.
    И в большинстве случаев компиляторы Java генерируют код весьма прямолинейно, следуя этим
    правилам, так, по что получаемому байт-коду можно зачастую однозначно определить вид исходного
    синтаксического дерева.
    \item В некотором смысле исключениeм является работа с константами:
    почти всегда, когда какое-то выражение может быть вычислено во время компиляции, в байт-коде
    будет уже результат этого вычисления.

    %% https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html
    Во многом это поведение описано в спецификации языка, и является полностью корректным,
    хотя в некоторых случаях неочевидным с точки зрения пользователя.

    \item Генерация последовательных применений оператора ``+'' для строк производится с помощью
    класса StringBuilder, что позволяет избежать избыточной аллокации и операций копирования памяти,
    которые неизбежно возникали бы в случае последовательных вызовов метода \textit{concat} у строк.

    \item Компилятор избегает генерацию заведомо мертвого кода, правда лишь в самых простых случаях.

    \item Некоторые простые оптимизации, применяемые при генерации условных операторов, упрощающие
    истиностные выражения в соответствии с законами де Моргана.
\end{itemize}

Кроме описанных в вышеуказанной статье пунктов стоит упомянуть несколько нетривиальную логику,
применяемую при генерации байт-кода для оператора ``switch'' для константных строк и более подробно
описанную в следующей главе. % link

Столь скудный набор оптимизаций, проводимых транслятором, вероятно связан с тем, что большая часть
работы с производительностью происходит уже во время работы программы на фазе JIT-компиляции.

% http://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/tooldocs/win32/javac.html
% http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.htm
% http://hg.openjdk.java.net/jdk6/jdk6/langtools/file/a9008b46db24/src/share/classes/com/sun/tools/javac/main/RecognizedOptions.java#l553
В пользу этого утверждения, в частности, говорит тот факт, что в документации к первым версиям
(до появления Hotspot) существовал флаг <<-O>>, позволяющий устанавливать уровень оптимизаций,
и который впоследствии из документации исчез.

Одним из выводов, который следует из этой части обзора --- код, генерируемый компилятором Java
может послужить эталоном для разработчика JVM-языка, как минимум в случае, когда
генерируемая конструкция достаточно проста, и присутствует в обоих языках: арифметические выражения,
простые условные операторы и т.д.
% http://www.mijnadres.net/published/Hotspot%20Optimizations.pdf
% https://www.usenix.org/legacy/events/jvm01/full_papers/paleczny/paleczny.pdf
% http://web.stanford.edu/class/cs343/resources/java-hotspot.pdf

В пользу последнего утверждения говорит также факт выполнения JIT-компилятором Hotspot
так называемых Peephole-оптимизаций[], шаблоны которых вполне вероятно могут быть приспособлены
именно для байт-кода, генерируемого компилятором Javac. Таким образом отступление от шаблонов
генерации Java потенциально может привести к ухудшению производительности.

\subsubsection{Java 8}
Одним из существенных нововведений, появившихся в относительно новой версии Java 8, стал лаконичный
синтаксис для анонимных функций.

В предыдущих версиях в случае необходимости определить функцию, параметризуемый некоторой другой
функцией, создавался интерфейс с одним методом, реализацию которого и следовало передать в первую
функцию.
% https://code.google.com/p/guava-libraries/wiki/FunctionalExplained
В популярной среди Java-разработчиков библиотеке <<guava>> для таких случае выделен общий
интерфейс, носящий недвусмысленное название Function[].

% https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.5
Чаще всего для реализации таких интерфейсов использовался громоздкий синтаксис анонимных классов[],
с помощью которого функцию-аргумент можно описать в месте вызова функции высшего порядка.
Примерно такой подход использовался и при генерации кода анонимных функций в новых языках для JVM:
для каждой из них генерировался отдельный синтетический класс с одним методом.

% http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html
При компиляции замыканий в Java 8 используется несколько другой подход: тело лямбда-функции
помещается в отдельный синтетический метод, располагаемый в том же классе, где происходит вызов
функции ожидающей реализацию интерфейса, а уже непосредственно класс-реализация генериуется
в момент первого вызова с помощью байт-код инструкции ``INVOKEDYNAMIC'', появишвшейся в поздних
версиях спецификаций JVM[]. % возможно стоит более подробно остановится?

Столь сложное и неочевидное решение, принятное инженерами Oracle, вряд ли существенно влияет на
производительность, так как фактически используется все тот же механизм интерфейсов и виртуальных
вызовов, намного сильнее такой подход влияет на число class-файлов в приложении.

Действительно, исходя из предположения об интенсивном использовании замыканий, генерация отдельного
class-файла в каждом месте вызова кажется избыточным, особенно учитывая, что не каждый из них
будет использован.

Однако у решения с ``INVOKEDYNAMIC'' есть как минимум один существенный недостаток: поддержка этой
инструкции существует только в версиях JVM младше седьмой, что сильно ограничивает возможность
использования такого кода в более старших версиях. В свою очередь попытки разработчиков языков
сохранить обратную совместимость например с версией JRE 1.6 зачастую являются не столько данью
консерватизму, сколько необходимостью для пользователей-разработчиков под Android, где по сей день
может быть использован только код, скомпилированный для устаревшей платформы.

\subsubsection{Scala}
Scala --- статически-типизированный мультипарадигменный язык программирования, компилируемый
в том числе под платформу Java. Системой типов, богатством синтаксических конструкций Scala
весьма сильно похож на Kotlin. В частности оба языка построены исходя из предположения
о повсеместном использовании функций высшего порядка, что сразу поднимает вопрос об эффективности
их реализации на уровне байт-кода.

В качестве основного источника информации о решениях, связанных с производительностью Scala,
автором была выбрана диссертация[] одного из разработчиков языка, который, как следует из статьи
занимался оптимизацией байт-кода, генерируемого компилятором.
Основные тезисы статьи будут рассмотрены в этом разделе.

\paragraph{Функции высшего порядка}
