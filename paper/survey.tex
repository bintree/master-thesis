\section{Обзор предметной области}

\subsection{Виртуальная машина Java}

В этом разделе будет описан ряд особенностей, с которыми сталкиваются разработчики языков
программирования,компилирующихся в байткод виртуальной машины Java, далее именуемой \textit{JVM}.

В первую очередь следует подчеркнуть, что JVM --- абстрактная виртуальная машина, работающая
в соответствии со официальной спецификацией, выпущенной компанией Sun Microsystems и ныне
принадлежащей компании Oracle. %% spec link in biblio

У нее существует множество реализаций, в разной степени удовлетворяющих требованиям спецификации.
Известными примерами могут послужить: \textit{Hotspot} и \textit{JRockit} от Oracle, \textit{Azul Zing}
и \textit{Azul Zulu} --- относительно новые реализации от компании Azul Systems, \textit{Apache Harmony},
и многие другие.

\paragraph{Байт-код}

Основной сущностью, с которой работает JVM, является так называемый <<class-файл>>, как правило являющийся
бинарным отражением отдельного класса из исходного кода на языке Java. В нем закодированы основные
характеристики класса, такие как набор полей и методов, информация о его происхождении --- имя
скомпилированного файла, набор используемых строковых констант, и многое другое.

В рамках описания отдельного метода наиболее важной его частью является непосредственно код --- список
инструкций, которые должны быть исполнены виртуальной машиной при вызове этого метода.

Стоит отдельно упомянуть об особенностях набора инструкций JVM, существенно отличающих его
от низкоуровневых наборов, таких как x86 или ARM, которые реализованы для большинства современных
процессоров:
\begin{enumerate}
    \item Интерпретатор JVM представляет собой стековую машину, то есть операнды инструкций, как и
    их результаты, располагаются на стеке, причем в рамках работы одного вызова метода
    нельзя получить доступ к стеку родительского вызова.
    \item В наборе инструкций отсутствуют механизмы для ``прямого'' доступа к памяти процесса, по
    спецификации JVM состояние программы исчерпывается содержимым локальных переменных вызовов,
    полей объектов и статических полей классов.
    \item Единственным способом интерпроцедурного взаимодействия является инструкция вызова метода.
    Существует несколько вариантов таких инструкций, и выбор конкретной определяется сигнатурой
    вызываемого метода и контекстом вызова. Важной особенностью является наличие ``встроенной''
    обработки \textit{виртуальных} вызовов, % link to smth?
    когда выбор конкретного метода, зависит от конкретного класса объекта, на котором он вызывается.
    \item В большинстве реализаций JVM так или иначе реализован механизм верификации class-файлов,
    проверяющий их корректность. В частности проверке подлежат тела методов. Например верификатор
    может идентифицировать использование неинициализированной локальной переменной,
    которое в противном случае могло бы привести к неопределенному поведению прграммы.
\end{enumerate}

С точки зрения разработчика языка, целевой платформой для которого выбрана JVM, перечисленные
особенности могут стать, как достоинствами, так и недостатками. Как и любая другая абстракция,
виртуальная машина упрощает работу с абстрагируемым предметом, одновременно лишая некоторой
гибкости.

\paragraph{Динамическая трансляция}
%% [CFM+97] T. Cramer, R. Friedman, T. Miller, D. Seberger, R. Wilson,
%% and M. Wolczko. Compiling Java, just in time. IEEE Micro,
%% 17(3):3~3, May-June 1997.

%% Execution Characteristics of Just-In-Time Compilers
%% R. Radhakrishnany, J. Rubioy, L. K. Johny and N. Vijaykrishnanz

Как уже было сказано выше, с точки зрения спецификации байт-код методов интепретируется виртуальной
машиной Java.
Первые ее реализации были устроены именно так, однако быстро выяснилось,
что такой подход достаточно сильно влияет на производительность программ.

Во многом это связано с тем, что по сути на процессоре исполняется два потока: поток интепретации
и поток программы.
Кроме того интерпретируемые программы не могут оптимально использовать регистры процессора и с ними
менее удачно удается работать процессорным конвейерам из-за сложностей с предсказанием переходов.


%% http://www.cs.tufts.edu/comp/150IPL/papers/aycock03jit.pdf
Вполне естественным решением описанных проблем стала динамическая компиляция, далее именуемая
\textit{JIT}-компиляцией или просто \textit{JIT}. Суть ее заключается в том, что весь байт-код
метода или существенная его часть в момент работы приложения полностью транслируется в машинный код,
и затем передается к исполнению непосредственно на процессор.

Несмотря на то, что такой подход не был исторически новым, именно реализация динамической
компиляции в Hotspot очень сильно повлияла на судьбу интепретируемых языков, в том числе
сам термин --- JIT-компиляция --- стал общеупотребительным в литературе именно после выпуска Hotspot.%%\cite{}

В рамках данной работы очень важной хактеристикой JIT-компиляторов, поставляемых вместе
с популярными реализациями JVM, является факт наличия в них оптимизирующих подсистем. Например
разработчики Hotspot заявляют о следующих оптимизациях, производимых при компиляции:
%% https://wikis.oracle.com/display/HotSpotInternals/PerformanceTechniques
\begin{enumerate}
    \item Свертка константных выражений.
    \item Оптимизация проверок, которые должна производить JVM, таких как отслеживание вызова
    метода на null-объекте, при котором должно быть активировано соответствующее исключение.
    \item Так называемая <<размотка цикла>>. %% cite?
    \item Удаление недостижимого кода.
    \item Встраивание тел вызываемых методов в место вызова, в том числе оптимистичное встраивание
    полиморфных методов.
    \item Оптимизации основанные на информации, полученной при первичной интерпретации кода,
    с возможностью последующей декомпиляции. Оптимизации такого рода принципиально недоступны
    в компилируемых языка, так как на момент компиляции информация о профиле ее исполнения чаще
    всего отсутствует.
\end{enumerate}

По сути JIT-компиляторы популярных реализаций JVM так или иначе применяют весь набор оптимизаций,
использующихся в промышленных компиляторах языков, транслирующих программы в машинный код.
Из этого можно сделать два вывода:
\begin{itemize}
    \item Производительность кода на Java как минимум не сильно уступает аналогичному коду,
    написанному на компилируемом языке.
    \item Разработчикам языков для JVM в большинстве случаев не нужно дублировать соответствующие
    оптимизации при трансляции в байт-код, так как они будут произведены в рамках фазы
    динамической компиляции.

    Разумеется этот вывод может быть корректным только в случае, когда производительностью кода
    на фазе интерпретации можно пренебречь, что кажется вполне разумным, так как большая часть
    приложений, написанных для Java-платформы запускаются на достаточно длительное время,
    чтобы скомпилировать наиболее часто интерпретируемый код.
\end{itemize}
