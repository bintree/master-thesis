\section{Обзор предметной области}

\subsection{Виртуальная машина Java}

В этом разделе будет описан ряд особенностей, с которыми сталкиваются разработчики языков
программирования, компилирующихся в байткод виртуальной машины Java, далее именуемой \textit{JVM}.

В первую очередь следует подчеркнуть, что JVM --- абстрактная виртуальная машина, работающая
в соответствии со официальной спецификацией\cite{JVMSpec}, выпущенной компанией Sun Microsystems и ныне
принадлежащей компании Oracle.

У нее существует множество реализаций, в разной степени удовлетворяющих требованиям спецификации.
Известными примерами могут послужить: \textit{Hotspot} и \textit{JRockit} от Oracle, \textit{Azul Zing}
и \textit{Azul Zulu} --- относительно новые реализации от компании Azul Systems, \textit{Apache Harmony},
и многие другие.

\paragraph{Байт-код}

Основной сущностью, с которой работает JVM, является так называемый <<class-файл>>, как правило являющийся
бинарным отражением отдельного класса из исходного кода на языке Java. В нем закодированы основные
характеристики класса, такие как набор полей и методов, информация о его происхождении --- имя
скомпилированного файла, набор используемых строковых констант, и многое другое.

В рамках описания отдельного метода наиболее важной его частью является непосредственно код --- список
инструкций, которые должны быть исполнены виртуальной машиной при вызове этого метода.

Стоит отдельно упомянуть об особенностях набора инструкций JVM, существенно отличающих его
от низкоуровневых наборов, таких как x86 или ARM, которые реализованы для большинства современных
процессоров:
\begin{enumerate}
    \item Интерпретатор JVM представляет собой стековую машину, то есть операнды инструкций, как и
    их результаты, располагаются на стеке, причем в рамках работы одного вызова метода
    нельзя получить доступ к стеку родительского вызова.
    \item В наборе инструкций отсутствуют механизмы для <<прямого>> доступа к памяти процесса, по
    спецификации JVM состояние программы исчерпывается содержимым локальных переменных,
    полей объектов и статических полей классов.
    \item Единственным способом интерпроцедурного взаимодействия является инструкция вызова метода.
    Существует несколько вариантов таких инструкций, и выбор конкретной определяется сигнатурой
    вызываемого метода и контекстом вызова. Важной особенностью является наличие ``встроенной''
    обработки \textit{виртуальных} вызовов, когда выбор конкретного метода, зависит от конкретного
    класса объекта, на котором он вызывается.
    \item В большинстве реализаций JVM так или иначе реализован механизм верификации class-файлов,
    проверяющий их корректность. В частности проверке подлежат тела методов. Например верификатор
    может идентифицировать использование неинициализированной локальной переменной,
    которое в противном случае могло бы привести к неопределенному поведению прграммы.
\end{enumerate}

С точки зрения разработчика языка, целевой платформой для которого выбрана JVM, перечисленные
особенности могут стать, как достоинствами, так и недостатками. Как и любая другая абстракция,
виртуальная машина упрощает работу с абстрагируемым предметом, одновременно лишая некоторой
гибкости.

\paragraph{Динамическая трансляция}
Как уже было сказано выше, с точки зрения спецификации байт-код методов интепретируется виртуальной
машиной Java.
Первые ее реализации были устроены именно так, однако быстро выяснилось,
что такой подход достаточно сильно влияет на производительность программ\cite{JavaJIT}.

Во многом это связано с тем, что по сути на процессоре исполняется два потока: поток интепретации
и поток программы.
Кроме того интерпретируемые программы не могут оптимально использовать регистры процессора и с ними
менее удачно удается работать процессорным конвейерам из-за сложностей с предсказанием
переходов\cite{JVMBranch}.


Вполне естественным решением описанных проблем стала динамическая компиляция, далее именуемая
\textit{JIT}-компиляцией или просто \textit{JIT}. Суть ее заключается в том, что весь байт-код
метода или существенная его часть в момент работы приложения полностью транслируется в машинный код,
и затем передается к исполнению непосредственно на процессор.

Несмотря на то, что такой подход не был исторически новым, именно реализация динамической
компиляции в Hotspot очень сильно повлияла на судьбу интепретируемых языков, в том числе
сам термин --- JIT-компиляция --- стал общеупотребительным в литературе именно после выпуска
Hotspot\cite{JITHistory}.

В рамках данной работы очень важной хактеристикой JIT-компиляторов, поставляемых вместе
с популярными реализациями JVM, является факт наличия в них оптимизирующих подсистем. Например
разработчики Hotspot заявляют о следующих оптимизациях, производимых при
компиляции\cite{HotSpotOT}:

\begin{enumerate}
    \item Свертка константных выражений.
    \item Оптимизация проверок, которые должна производить JVM, таких как отслеживание вызова
    метода на null-объекте, при котором должно быть активировано соответствующее исключение.
    \item Так называемая <<размотка цикла>>.
    \item Удаление недостижимого кода.
    \item Встраивание тел вызываемых методов в место вызова, в том числе оптимистичное встраивание
    полиморфных методов.
    \item Оптимизации основанные на информации, полученной при первичной интерпретации кода,
    с возможностью последующей декомпиляции. Оптимизации такого рода принципиально недоступны
    в компилируемых языка, так как на момент компиляции информация о профиле ее исполнения чаще
    всего отсутствует.
\end{enumerate}

По сути JIT-компиляторы популярных реализаций JVM так или иначе применяют весь набор оптимизаций,
использующихся в промышленных компиляторах языков, транслирующих программы в машинный код.
Из этого можно сделать два вывода:
\begin{itemize}
    \item Производительность кода на Java как минимум не сильно уступает аналогичному коду,
    написанному на компилируемом языке.
    \item Разработчикам языков для JVM в большинстве случаев не нужно дублировать соответствующие
    оптимизации при трансляции в байт-код, так как они будут произведены в рамках фазы
    динамической компиляции.

    Разумеется этот вывод может быть корректным только в случае, когда производительностью кода
    на фазе интерпретации можно пренебречь, что кажется вполне разумным, так как большая часть
    приложений, написанных для Java-платформы запускаются на достаточно длительное время,
    чтобы скомпилировать наиболее часто интерпретируемый код.
\end{itemize}

\paragraph{Параметрический полиморфизм}
Начиная с версии 1.5 в Java появилась возможность указывать типовые параметры классов, таким
образом используя концепцию параметрического полиморфизма.
Этот вид полиморфизма позволяет определять функцию или класс обобщённо, так что значения
обрабатываются идентично вне зависимости от конкретного типа типа.
Чаще всего эта возможность используется в классах-коллекциях, однако существует и множество
других вариантов ее применения.

Важным отличием реализации типовых параметров в Java в сравнении, например, с аналогами из C\#
стало то, что информация о параметрах существует только на фазе компиляции.
В скомпилированном байт-коде класса с типовыми параметрами, все их упоминания в коде заменяются на
так называемый <<Высший тип>>, которым чаще всего является класс ``java.lang.Object'', от которого
неявно наследуются все остальные классы. Этот метод в литературе часто называют <<стирание типов>>.

Другим способом реализации этого вида полиморфизма является копирование параметризованной сущности
для каждого подставляемого типа, т.н. специализация. Именно такой подход используется в
CLR\cite{CLRGenerics}.

У стирания типов есть несколько существенных недостатков:
\begin{itemize}
    \item Ограничены варианты использования типового параметра внутри параметризованной сущности:
    нельзя использовать операторы приведения типа к ``T'', нельзя создать объект или массив
    типа ``T''.
    \item Примитивные типы в Java, такие как числа или истиностные значения, существенно отличаются
    по своей природе от классов: объекты классов хранятся в динамической памяти и программист
    может оперировать только ссылками на них, а значения примитивных типов могут хранится на стеке,
    и работа с ними может производиться без ссылочной косвенности.

    Такое разделение позволяет избежать проблем с производительностью при интенсивных численных
    вычислениях.

    Однако из-за этого примитивные типы невозможно использовать в качестве типового параметра,
    так как при работе со значениями таких типов в байт-коде используются специфичные инструкции,
    отличные от тех, которые оперируют ссылочными типами.

    В частности для решения этой проблемы используются специальные классы-обертки, хранящие внутри
    себя одно поле --- значение примитивного типа. В стандартной библиотеке Java предложен набор
    таких классов, по одному на каждый примитивный тип: java.lang.Integer для int,
    java.lang.Boolean для boolean и т.д. Операция получения объекта-обертки по значению
    в литературе носит название <<авто-боксинг>> (auto-boxing) или просто <<боксинг>> (boxing).

    Проблема боксинга заключается в создании объектов в динамической памяти, что само по себе
    не слишком эффективно, а кроме этого увеличивает нагрузку на сборщик мусора.

    Более подробно проблема боксинга рассмотрена в разделах \ref{section:inline:bm} и \ref{section:boxing}.
\end{itemize}

\subsection{Байт-код для функциональных типов в Kotlin}
\label{section:lambda}
Одним из наиболее важных преимуществ современных языков для JVM является возможность использования
функций в качестве значений.
Например в Kotlin можно объявить функцию высшего порядка ``map'', применяющую произвольную операцию
к каждому элементу массива:

\begin{pyglist}[language=kotlin]
fun <T, R> map(xs: Array<T>, f: (T) -> R): Array<R> = ...
\end{pyglist}

Параметр ``f'' --- это функция, принимающая аргумент типа ``T'', которая возвращающает значение
типа ``R''.

Типичный пример вызова такой функции для преобразования целочисленного массива:
\begin{pyglist}[language=kotlin]
    val outerVar = 1
    val ys = map(xs, fun(x: Int): Int = x + outerVar)
\end{pyglist}

При компиляции в class-файлы все функциональные типы транслируются в интерфейсы ``FunctionK''
вида:
\begin{pyglist}[language=java]
interface FunctionK<A1, .., Ak, R> {
    R invoke(A1 x1, .., Ak xk);
}
\end{pyglist}

В свою очередь каждое функциональное выражение компилируется в отдельный синтетический класс,
реализующий этот интерфейс. Например вышеуказанный вызов ``map'' в байт-коде после стирания типов
выглядит, как если бы на Java был написан следующий код:
\begin{pyglist}[language=java]
    int outerVar = 1;
    int[] ys = map(xs,
    new Function1() {
        // final int outerVar = outerVar;
        @Override
        Object invoke(Object x) {
            return Integer.valueOf(invoke(((Integer)x).intValue()));
        }
        int invoke(int x) { return x + outerVar; }
    });
\end{pyglist}

Важно отметить, что в классе определено синтетическое два метода и поле:
\begin{itemize}
    \item Метод ``invoke(int)'' не учавствует непосредственно в реализации интерфейса, типы его
    сигнатуры и его тело в точности повторяют типы и тело анонимной функции.

    \item Метод ``invoke(Object)'' реализует интерфейс ``Function1'' и является параметрически полиморфным,
    и как следствие все типы его сигнатуры, взятые из параметров заменены на Object.

    Семантика тела этого метода состоит в приведении типов из Object к типам анонимной функции,
    в том числе <<распаковка>> из аргументов, с последующей
    делегацией в ``invoke(int)'', а также боксинг результата.

    \item Поле ``outerVar'', объявленное в классе, демонстрирует то, как влияет на байт-код
    использование внешних переменных в замыкании:
    \begin{itemize}
        \item В случае, когда переменная объявлена, как неизменяемая (модификатор ``val''), ее
        значение передается в конструктор класса и сохраняется в одноименное синтетическое поле
        объекта.
        Таким образом доступ к внешней переменной заменяется на доступ к полю.
        \item Особым случаем являются изменяемые переменные, объявленные с модификатором ``var''.
        Их изменение должно влиять, как на значение в замыкании, так и на значение в функции, где
        они объявлены. В JVM отсутствует естественный механизм для решения этой проблемы, так как
        локальные переменные одного вызова, хранимые в его кадре стека, принципиально недоступны
        из другого вызова, и в Java такой вариант использования запрещен спецификацией.

        В Kotlin значение изменяемой переменной, используемой в замыкании, приходится хранить
        в объекте-оболочке в динамической области памяти, что позволяет разделять это значение
        между разными вызовами.
    \end{itemize}
\end{itemize}
