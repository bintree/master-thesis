\section{Изменения в компиляторе}
В рамках данной главы будут описаны изменения в компиляторе, направленные на решение проблем,
найденных в разделе \ref{section:benchmarks}.

\subsection{Архитектура компилятора}
Большинство современных компиляторов, включая Kotlin, реализуют архитектурный шаблон, описанный
в \cite{Muchnick}.

Его суть состоит в разделении всего кода на следующие компоненты, каждая из которых должна зависеть
только от предыдущих:
\begin{enumerate}
    \item \textit{Лексический анализатор} --- принимает на вход содержимое программы в виде строки
    символов, и выдает поток семантически значимых фрагментов, т.н. <<токенов>>.

    \item \textit{Синтаксический анализатор} --- реализует один из алгоритмов синтаксического
    анализа и строит из потока <<токенов>> абстрактное синтаксическое дерево.

    \item \textit{Семантический анализатор}, получая абстрактное синтаксическое дерево, производит
    вывод типов выражений, если это необходимо, и проверяет корректность программы с точки зрения
    спецификации языка и его системы типов.

    \item \textit{Генератор кода} --- подсистема, генерирующая по размеченному синтаксическому
    дерево код для целевой архитектуры, в случае Kotlin --- class-файлы виртуальной машины Java.
\end{enumerate}

Для данной работы наибольший интерес, очевидно, представляет именно генератор кода.
Его часть, отвечающая за генерацию байт-кода методов представлена в виде класса, реализующего
шаблон проектирования <<Посетитель>>\cite{Gamma}, каждый ``visit''-метод которого отвечает за
генерацию отдельного вида узлов синтаксического дерева и чаще всего выполняет контракт,
гарантирующий, что результат аргумента-выражения окажется на вершине стека.

\subsection{Безопасный вызов и elvis-оператор}
\label{section:elvis:op}
%\begin{verbatim}
                %aload_1 // Загрузка `obj` на стек
                %dup
                %ifnull l1
                %getfield x
                %invokestatic  java/lang/Integer.valueOf() // Боксинг
                %goto          l3
                %l1: pop
                %aconst_null
                %// начало кода elvis-оператора
                %l2: dup
                %ifnull l3
                %invokevirtual java/lang/Number.intValue() // Распаковка
                %goto          l4
                %l3: pop
                %iconst_1
                %l4: ...
%\end{verbatim}

В разделе \ref{section:elvis:bm} были описаны произведенные измерения, демонстрирующие низкую
производительность байт-кода для сочетания безопасного вызова и elvis-оператора.

Ниже произведен более подробный анализ байт-кода бенчмарков и описаны решения для оптимизации.

\begin{figure}
\begin{center}
    \includegraphics[scale=0.4]{../resources/safecall_elvis.png}
\end{center}
\caption{Блок-схема байт-кода для выражения ``return (obj?.x ?: 1)''}
\label{sc:elvis}
\end{figure}

Примерная блок-схема байт-кода бенчмарка изображена на рисунке \ref{sc:elvis}.
Часть, расположенная выше пунктирной линии описывает генерацию безопасного вызова:
\begin{itemize}
    \item На стек загружается переменная ``obj'', ее значение копируется с помощью инструкции
    ``DUP'', и копия проверяется на равенство ``null''.
    \item В случае если ``obj'' является нулевой ссылкой, то лежащее на вершине стека значение
    тоже нулевая ссылка.
    Иначе на стеке лежит объект ``obj'', у которого берется значение в поле ``x'' и упаковывается.
\end{itemize}

Таким образом обеспечивается контракт безопасного вызова, и на вершине стека находится либо нулевая
ссылка, либо упакованное значение поля.

Боксинг в данном случае необходим, так как ситуация, когда при одном потоке исполнения в ячейке
стека значение примитивного типа, а при другом --- ссылка, запрещена спецификацией виртуальной
машины\cite{JVMSpec}.

Вторая часть блок-схемы иллюстрирует байт-код для elvis-оператора:
\begin{itemize}
    \item Значение, лежащее на вершине стека, копируется и проверяется на равенство нулевой ссылке.
    \item В случае, если оно является нулевой ссылкой, то его копия снимается со стека и
    загружается значение по умолчанию --- целочисленная константа <<1>>.

    Иначе не стеке лежит объект класса ``java.lang.Integer'', из которого и получается значение
    с помощью вызова метода ``intValue'', на блок-схеме этот вызов отмечен для простоты, как
    ``UNBOX''.
\end{itemize}

Понятно, что байт-код этих операторов по отдельности наиболее очевидным образом выражает
их семантику, и выразить их еще проще в рамках спецификации JVM, пожалуй, не представляется
возможным.
Однако их сочетание ни в коей мере оптимальным не кажется.

\begin{figure}
\begin{center}
    \includegraphics[scale=0.4]{../resources/safecall_elvis_optim.png}
\end{center}
\caption{Блок-схема байт-кода для выражения ``return (obj?.x ?: 1)'' (оптимальный вариант)}
\label{sc:elvisOpt}
\end{figure}

Наиболее кратким вариантом трансляции кажется изображенный на рисунке \ref{sc:elvisOpt}:
\begin{itemize}
    \item Переменная ``obj'' загружется на стек, создается ее копия, и сравнивается с нулевой
    ссылкой.
    \item Если значение является нулевой ссылкой, то его копия снимается со стека, и загружается
    значение по умолчанию.
    Иначе на вершине стека хранится объект, у которого берется значение поля ``x''.
\end{itemize}

При такой генерации отсутствуют операции боксинга, что, как выяснилось в рамках измерений,
хуже всего влияет на производительность вышеописанного байт-кода.

\paragraph{Решение}
В связи с условной оптимальностью байт-кода для операторов по отдельности, наиболее разумным
решением кажется специализация кодогенерации для выражений вида: $x_1?.x_2?...?.x_k\ ?: default$
в соответствие с идеей, проилюстрированной на рис. \ref{sc:elvisOpt}.

Упрощенно суть изменений можно выразить в виде следующего псевдокода:
\begin{lstlisting}[frame=single]
    function genElvis(v1: Expr, v2: Expr) {
        if (v1 is SafeCallChain) {
            // v1 ~ x1?.x2?...?.xk
            genSafeCallChain(v1, defaultLabel);
        } else {
            gen(v1);
        }

        DUP();
        IFNULL(defaultLabel);

        // ifNullLabel starts here
        gen(v2);
    }

    function genSafeCallChain(v: safeCallChain, ifNullLabel: Label) {
        for (element in v) {
            gen(v);
            DUP();
            IFNULL(ifNullLabel);
        }
    }
\end{lstlisting}

По сути логика генерации осталась прежней за исключением изменения генерации безопасных вызовов:
при проверке аргумента на равенство нулевой ссылке, сразу происходит переход к инструкции,
с которой начинается генерация значения по умолчанию.

Аналогичная оптимизация была произведена и для цепочки безопасных вызовов вне elvis-оператора,
в таком случае код можно генерировать по аналогии с выражением ``x1?.x2?..?.xk ?: null''.

В совокупности с изменениями, описанными в следующем разделе, это решение способствовало улучшению
производительности байт-кода, как микро-бенчмарков из раздела \ref{section:elvis:bm}, так и кода
АВЛ-дерева из раздела \ref{section:avl:bm}.
Результаты измерений в таблицах \ref{bm:elvis:o} и \ref{bm:stars:o}.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|} \hline
$p$ & Эталон (мкс) & До оптимизаций (мкс) & После оптимизаций (мкс) & Ускорение \\ \hline
0.1 & 4.693 $\pm$ 0.036 & 9.131 $\pm$ 0.126 & 4.619 $\pm$ 0.039 & 1.977\\ \hline
0.5 & 7.103 $\pm$ 0.078 & 7.138 $\pm$ 0.263 & 7.105 $\pm$ 0.039 & 1.005\\ \hline
0.9 & 4.561 $\pm$ 0.043 & 4.738 $\pm$ 0.047 & 4.523 $\pm$ 0.064 & 1.048\\ \hline
\end{tabular}
\caption{Результаты бенчмарка "Безопасный вызов и elvis" после оптимизаций \newline (p --- вероятность нулевой ссылки)}
\label{bm:elvis:o}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|} \hline
Размер & Java & Kotlin & После оптимизаций & Ускорение \\ \hline
100 & 19.412 $\pm$ 0.266 мкс & 30.687 $\pm$ 1.66 мкс & 21.837 $\pm$ 0.309 мкс & 1.405\\ \hline
1000 & 300.055 $\pm$ 2.397 мкс & 476.807 $\pm$ 4.243 мкс & 335.531 $\pm$ 11.768 мкс & 1.421\\ \hline
100000 & 78.686 $\pm$ 3.14 мс & 132.768 $\pm$ 3.938 мс & 79.394 $\pm$ 1.896 мс & 1.672\\ \hline
\end{tabular}
\caption{Результаты бенчмарка <<АВЛ-дерево>> после оптимизаций}
\label{bm:stars:o}
\end{center}
\end{table}

\subsection{Оператор when для константных выражений}
Измерения, результаты которых изложены в разделе \ref{section:when:bm}, показали, что использование
байт-код инструкций ``tableswitch'' и ``lookupswitch'' для оператора ``when'' с константными
выражениями может значительно улучшить производительность соответствующего участка байт-кода.

Эти инструкции объединяет общая семантика:
\begin{itemize}
    \item Они параметризуются отображением из набора целых чисел в указатели на другие инструкции
    метода.
    \item При исполнении инструкции интерпретатор снимает с вершины стека число и совершает
    соответствующий переход.
\end{itemize}

Различия заключаются в том, что
\begin{itemize}
    \item \textit{tableswitch} параметризуется интервалом $[high..low]$.
    Для каждого целочисленного значения из этого интервала должна быть задана метка перехода,
    а кроме этого указатель на инструкцию по умолчанию.

    Таким образом размер этой инструкции линейно зависит от ширины интервала.
    \item \textit{lookupswitch} параметризуется отсортированным набором пар значений и меток
    перехода.

    Размер такой инструкции зависит линейно от числа значений.
\end{itemize}

Несмотря на то, что в спецификации не указана трудоемкость выполнения этих инструкций, из формата
их описания понятно, что ``tableswitch'' может быть исполнен за $O(1)$ прямым вычислением индекса
следующей инструкции, а ``lookupswitch'' может быть реализован на основе бинарного поиска и
работать за $O(log\ n)$.

\paragraph{Выбор инструкции}
Сама по себе задача генерации специальных инструкций для случая, когда все выражения
для сопоставления в ``when'' --- константы, не представляется алгоритмически сложной, с учетом
наличия в компиляторе подсистемы для вычисления констант времени компиляции.

Однако существует некоторое количество тонкостей, о которых следует упомянуть в рамках данного
раздела.

Например при реализации неизбежно возникает проблема выбора между двумя инструкциями,
являющаяся по сути задачей многокритериального анализа:
\begin{itemize}
    \item ``tableswitch'' вероятно более производительна, но ее размер в байт-коде линейно
    пропорционален ширине интервала.
    \item ``lookupswitch'' более компактна, ее размер в байт-коде пропорционален числу меток.
\end{itemize}

В результате было принято решение воспользоваться эвристическим алгоритмом, который используется
для выбора инструкции в компиляторе Java из набора OpenJDK\fu{https://github.com/openjdk-mirror/jdk7u-langtools/blob/9f03d0c131f6343fee00f5dc5485c047e5cd2033/src/share/classes/com/sun/tools/javac/jvm/Gen.java\#L1159}:
\begin{itemize}
    \item Для каждого из вариантов вычисляется его условная стоимость как сумма стоимостей
    по памяти и производительности в виде числа сравнений --- $spaceCost + 3 * timeCost$

    \item Для ``tableswitch'' его стоимость по памяти полагается равной числу занимаемых машинных
    слов, т.е. $spaceCost = 4 + (high - low)$.

    Его трудоемкость оценивается значением $timeCost = 3$: два сравнения, необходимые для проверки,
    что данное число помещается в интервал $high..low$, и одно действие для безусловного прыжка.

    \item Для ``lookupswitch'': $spaceCost = 3 + 2 * n, timeCost = n$, где $n$ --- число меток.

    \item Вычисленные условные стоимости сравниваются и выбирается вариант с наименьшим
    результатом.
\end{itemize}

\paragraph{Оператор when для строк}
Для эффективного использования switch-инструкций, которые могут работать только с целочисленными
аргументами, при сравнении строк, используется хеш-функция, определенная в классе
``java.lang.String''.

Разумеется из равенства значений хеш-функций нельзя делать выводы о равенстве строк,
поэтому в каждой метке switch-инструкции необходимо произвести соответствующие проверки.

Также следует обработать редкий случай, когда коллизии возникают между различными строками
из набора выражений для сопоставления.

Получаемый при генерации байт-код мог бы быть получен при компиляции следующего кода,
если бы в Java был реализован оператор ``goto''.
\begin{pyglist}[language=java]
String tmp0 = x;
switch(tmp0.hashCode()) {
    case 101584: if (tmp0.equals("foo")) { goto l1; }
    case 97299: if (tmp0.equals("bar")) { goto l2; }
}
l1: ...
l2: ...
\end{pyglist}

Любопытной деталью, является тот факт, что в компиляторе Java оператор ``switch'' для строк еще
до фазы генерации кода трансформируется в ``switch'' для целочисленных значений примерно такого же
вида, как изображенный выше код.
Однако ввиду отсутствия в языке конструкции ``goto'' его поведение эмулируется сохранением
во временную переменную номера совпавшей строки и дополнительным ``switch'' от этой переменной.

А так как изменения в компиляторе Kotlin производились внутри фазы кодогенерации, автору удалось
избавитсься от этой избыточности, и таким образом получить версию примерно на 10\% эффективней
версии Java (см. таблицу \ref{bm:switch:opt}).

\paragraph{Оператор when для enum-классов}
Для использования ``switch''-инструкций при генерации when для enum-классов использовался метод
``ordinal()`` определенный для каждой enum-константы, и возвращающий ее порядковый номер.

Однако компилятор Java выполняет дополнительную микрооптимизацию:
\begin{itemize}
    \item Для каждого класса, в котором вызывается ``switch'' от enum-класса, создается
    синтетический вложенный класс со статическими полями-массивами --- по одному на каждый такой
    ``switch''.
    \item Каждый массив имеет размер равный числу enum-констант в конкретном классе, и имеет смысл
    отображения порядковых номеров констант, используемых в метках, в последовательные номера
    от единицы.
    \item И вместо ``switch'' по непосредственному значению ``ordinal()`` генерируется ``switch''
    по элементу в соотвествующем массиве с индексом ``ordinal()''
\end{itemize}

Эта оптимизация, как следует из комментария к исходному коду, направлена на то, чтобы гарантировать
эффективное использование ``tableswitch'' при генерации оператора ``switch'' для enum-классов.

Реализация оптимизации ``when'' в Kotlin была сделана аналогично, в результате чего получаемый
байт-код можно проиллюстрировать следующим кодом на Java:
\begin{pyglist}[language=java]
    switch(CurrentClass$Mappings.$Mapping0[x.ordinal()]) {
        case 0: // ...
        case 1: // ...
        ...
    }
\end{pyglist}

\paragraph{Измерения после оптимизаций}
После внедрения описанных выше оптимизаций результаты бенчмарков, описанных
в разделе \ref{section:when:bm}, стали аналогичным результатам эталонных версий, написанных
на Java, кроме бенчмарка со строками, который стал производительней <<эталонного>> варианта на 10\%.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|} \hline
Разреженность & Java (мкс) & Kotlin (мкс) & После оптимизаций (мкс) & Ускорение \\ \hline
1..20 & 4.281 $\pm$ 0.018 & 7.8 $\pm$ 0.131 & 4.284 $\pm$ 0.029 & 1.821\\ \hline
1..20, 100500 & 5.554 $\pm$ 0.077 & 7.524 $\pm$ 0.065 & 5.55 $\pm$ 0.068 & 1.356\\ \hline
\end{tabular}
\caption{Сравнение производительности операторов switch/when для целочисленных констант после оптимизаций}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|} \hline
Тип & Java (мкс) & Kotlin (мкс) & После оптимизаций (мкс) & Ускорение \\ \hline
Enum & 10.501 $\pm$ 0.167 & 13.885 $\pm$ 0.037 & 10.476 $\pm$ 0.086 & 1.325\\ \hline
Строки & 21.667 $\pm$ 0.205 & 81.931 $\pm$ 1.671 & 19.295 $\pm$ 0.117 & 4.246\\ \hline
\end{tabular}
\caption{Сравнение производительности операторов switch/when для классов перечислений и строк после оптимизаций}
\label{bm:switch:opt}
\end{center}
\end{table}

\input{postprocessing}
